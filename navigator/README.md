# Navigator

This library sits on top of AndroidX Navigation and solves 2 problems that we ran into after
starting to adopt it.

1. We believe that navigation should be triggered from the business logic. This way it is easily
   testable in isolation without having to actually navigate inside a
   running app. However you usually want to keep Android specific components out of these layers
   and passing `NavController` there would risk leaking the Activity.

2. The XML based declaration of destinations did not scale well with our heavily modularized code
   base. Each screen is usually located in its own feature Gradle module and those should stay 
   independent of each other. That effectively meant that each XML file had a single destination 
   and all destination ids needed to be defined somewhere else so that feature modules 
   can navigate to each other. Since the code generated by safe-args plugin also lives in the 
   feature module it's not usable by other features either. That meant that in the end we didn't get 
   the nice type safety advantages of safe-args and the XML was just boilerplate that didn't
   form a real graph in the end.

## Destinations

To replace the XML and get type safety for navigation the library has its own concept of
destinations. A destination consists of 2 things:
- the declaration of the destination itself which determines what is shown when the destination is navigated to;
- the route - a way to reach the destination.

### NavRoute

The route part is represented by the `NavRoute` interface. Each destination will get its own
implementation of this interface and screens can use it to navigate to the destination.

The most minimal implementation of `NavRoute` would be for a screen that doesn't require any
arguments can be a simple Kotlin object:
```kotlin
@Parcelize
object HomeScreenRoute : NavRoute
```

The more common case when a destination needs arguments passed to it would look like this:
```kotlin
@Parcelize
data class DetailScreenRoute(
    val id: String,
) : NavRoute
```

Internally the library will pass the route to the screen itself so that it can access the parameters.

### NavDestination

The other part of the destination is represented by `NavDestination`. These work slightly
differently based on whether you are using `Fragment` navigation or pure Compose navigation
(a Fragment with composables in it would still count as `Fragment` navigation).

#### Compose

If we take the `DetailScreenRoute` example from above, declaring the destination for it would look
like this:

```kotlin
val detailScreenDestination: NavDestination = ScreenDestination<DetailScreenRoute> { route: DetailScreenRoute ->
    DetailScreen(route)
}
```

The `ScreenDestination` function will return a new `NavDestination` which is linked to the route
that was passed as the generic type parameter. The lambda function then gets an instance of that
`NavRoute` and calls the `@Composable` function that should be shown.

The other 2 functions to create destinations are `DialogDestination` and `BottomSheetDestination` -
they declare destinations that use a dialog or bottom sheet as a container instead of being shown
full screen.

These destinations can then be passed to a `NavHost` by putting them into a set:
```kotlin
setContent {
    NavHost(
        startRoute = HomeScreenRoute, // route to the screen that should be shown initially
        destinations = setOf(homeDestination, detailScreenDestination)
    )
}
```

#### Fragment

The approach for Fragments is very similar:

```kotlin
val detailScreenDestination: NavDestination = ScreenDestination<DetailScreenRoute, DetailFragment>()
```

The `ScreenDestination` function will return a new `NavDestination` which is linked to the route
that was passed as the first generic type parameter. The second type parameter is the `Fragment`
that will be shown for this destination.

Like the compose destination functions there is also `DialogDestination` to have a `DialogFragment`
destination. BottomSheetDestination does not exist because this would simply be a
`DialogDestination` with a `BottomSheetDialogFragment`.

These destinations can then be passed to a `NavHostFragment` by putting them into a set:
```kotlin
navHostFragment.setGraph(
    startRoute = HomeScreenRoute, // route to the screen that should be shown initially
    destinations = setOf(homeDestination, detailScreenDestination)
)
```

Inside a Fragment the `requireRoute` extension method can be used to obtain the `NavRoute`
used to navigate to it.

For example the `DetailFragment` could do this to obtain `DetailScreenRoute` and access the `id` in
it:
```kotlin
val route = requireRoute<DetailScreenRoute>()
```

#### Scalability

For the simplicity of the examples above the destinations were just kept in a variable and
the set was created directly calling `NavHost`/`setGraph`. In practice it makes more sense
to use dagger multibindings for these:

```kotlin
@Module
object DetailScreenModule {
    @Provides
    @IntoSet
    fun provideDetailScreenDestinations(): NavDestination = ScreenDestination<DetailScreenRoute> {
        DetailScreen(it)
    }
}
```

Then an `Activity` or something else can simply inject a `Set<NavDestination>`
```kotlin
class MainActivity : ComponentActivity() {
    @Inject
    lateinit var destinations: Set<NavDestination>

    override fun onCreate(savedInstanceState: Bundle) {
        super.onCreate()
        // inject the activity
        setContent{
            NavHost(
                startRoute = HomeScreenRoute,
                destinations = destinations
            )
        }
    }
}
```

## Nav events

The third main class that the library provides is `NavEventNavigator`. This class solves the first
of our 2 problems, triggering navigation from outside the UI layer. For that it has all the
primitive navigation operations:

```kotlin
// navigate to the destination that the given route leads to
navigator.navigateTo(DetailScreenRoute("some-id"))
// navigate up in the hierarchy
navigator.navigateUp()
// navigate to the previous destination in the backstack
navigator.navigateBack()
// navigate back to the destination belonging to the referenced route and remove all destinations
// in between from the back stack, depending on inclusive the destination
navigator.navigateBackTo<MainScreenRoute>(inclusive = false)
```

These methods can be called from anywhere and it's safe to hold an instance of the
`NavEventNavigator` in places where it survives configuration changes.

For the navigation to actually be executed call `handleNavigation(this, navigator)` from your one of
the Fragment lifecycle methods or `NavigationSetup(navigator)` from a composable function.

It's possible to simply instantiate an instance of `NavEventNavigator` but in the Freeletics code
base we usually create a subclass in each feature module that has some higher level methods. For
example it could have a method that encapsulates the creation of the route:
```kotlin
fun navigateToDetail(id: String) {
    navigateTo(DetailScreenRoute(id))
}
```
They can also contain more complex logic like navigating to one route or another based on a
parameter or first calling `navigateBackTo` and then `navigateTo` with a new route. This
keeps the navigation logic more separated and it can be easily called from more than one place.


## Other concepts

### Multiple back stacks

The library provides support for AndroidX Navigation's multi back stack feature. To use the feature
the root of a back stack should use `NavRoot` instead of `NavRoute` for its route class. Then it's
possible to navigate to the backstack using
`NavEventNavigator.navigateToRoot(ProfileTabRoot, restoreRootState = false)`. This will save the
current back stack's state, clear it and then do one of two things based on the `restoreRootState`
parameter. If it is `true` and there is one it will restore the back stack that is associated
with `ProfileTabRoot`. If it's `false` or there is no matching back stack that was previously saved
the destination for `ProfileTabRoot` will be shown.

### Handling back clicks

`NavEventNavigator` has a `backPresses()` method that returns `Flow<Unit>` which will emit
whenever Android's back button is used. While this `Flow` is collected the default back handling
is disabled. This can be used to for example show a confirmation dialog before navigating back.

### Activity destinations

It is also possible navigate to an `Activity` both inside and outside of the app. In both cases
it's required to define an `InternalActivtyRoute` or `ExternalActivityRoute` as well as an 
`ActivityDestination` like for any other screen. The route can then simply be passed to `navigateTo` 
to start the associated `Activity`. The `ActivityDestination` is just another `NavDestination` 
than can be added to the `Set` with all other destinations.

`InternalActivtyRoute` is meant for `Activity` instances in the current app and can be obtained
in the launched activity by calling `getRoute` or `requireRoute` to read parameters passed to it.


This is example shows the route and destination for a `SettingsActivity`:
```kotlin
@Parcelize
data class SettingsActivityRoute(
    val id: String,
) : InternalActivityRoute()

val extraActivityDestination: NavDestination = ActivityDestination<SettingsRoute>(
    intent = Intent(context, SettingsActivity::class)
)
```

Activities in other apps can be targeted with `ExternalActivityRoute` which allows enriching the
resulting `Intent` with it's `fillInIntent` method.

```kotlin
// minimal route
@Parcelize
object PlayStoreRoute : ExternalActivityRoute

val playStoreDestination: NavDestination = ActivityDestination<PlayStoreRoute>(
    // full intent is statically defined
    intent = Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=${context.packageName}"))
)

// route with extra values
@Parcelize
class ShareRoute(
    private val title: String,
    private val message: String
) : ExternalActivityRoute {
    // the returned Intent is filled into the Intent of the destination by calling
    // destinationIntent.fillIn(fillInIntent())
    override fun fillInIntent() = Intent()
        .putExtra(Intent.EXTRA_TITLE, title)
        .putExtra(Intent.EXTRA_INTENT, Intent().apply {
            action = Intent.ACTION_SEND
            type = "text/plain"
            putExtra(Intent.EXTRA_TEXT, message)
        })
}

val shareDestination: NavDestination = ActivityDestination<ShareRoute>(
    // basic intent that is extended with the Intent above
    intent = Intent(Intent.ACTION_CHOOSER)
)

// route with a data uri extra
@Parcelize
class BrowserRoute(
    uri: Uri,
) : ExternalActivityRoute {
    // the returned Intent is filled into the Intent of the destination by calling
    // destinationIntent.fillIn(fillInIntent())
    override fun fillInIntent() = Intent().setData(uri)
}

val browserDestination: NavDestination = ActivityDestination<BrowserRoute>(
    // basic intent that is extended with the Intent above
    intent = Intent(Intent.ACTION_VIEW)
)
```

All shown approaches can be combined where for example some extras are statically added to the
`Intent` when the destination is created and some others are dynamically provided through
`fillInIntent`.

### Activity results

External SDKs and the framework often provide an `Activity` that is supposed to be used with
`startActivityForResult`. AndroidX already introduced `ActivityResultContract` to simplify handling
this and `NavEventNavigator` uses them to also enable starting them from outside the UI layer
and receiving results there.

To use the API `registerForActivityResult` needs to be called with an instance of the wanted
`ActivityResultContract`. This needs to happen before `handleNavigation`/`NavigationSetup`
is called for the navigator, so it is recommended to do this during the construction of the
navigator. The method returns an `ActivityResultRequest` object that can be then used for two
things. It can be passed to `navigateForResult(request)` to launch the contract. It also has a
`results` property that returns a `Flow<O>`, where `O` is the contract's output type, to make it
possible to receive the returned results.

This is an example navigator that allow navigating to the camera or the system file picker to
take or pick an image:
```kotlin
class MyNavigator : NavEventNavigator() {
    val cameraImageRequest = registerForActivityResult(ActivityResultContracts.TakePicture())
    val galleryImageRequest = registerForActivityResult(ActivityResultContracts.GetContent())


    fun takePicture(uri: Uri) {
        // the uri here is the parameter that the TakePicture contract expects
        navigateForResult(cameraImageRequest, uri)
    }

    fun pickPicture() {
        navigateForResult(galleryImageRequest, "image/*")
    }
}
```

In the example above `cameraImageRequest.results` returns a `Flow<Boolean>` and
`galleryImageRequest.results` a `Flow<Uri?>` which can both be collected to handle the results.

### Requesting permissions

The Activity result APIs can already be used with `ActivityResultContracts.RequestPermission` or
`ActivityResultContracts.RequestMultiplePermissions` to also handle requesting Android runtime
permission requests. `NavEventNavigator` provides a slightly higher level API for this.

To use this call `registerForPermissionResult`, which should be done during the construction
of the navigator or shortly after. This can then be passed to `requestPermissions` with one or
more permission to request to launch the request. Results can be collected through the
`Flow<Map<String, PermissionResult>>` that is returned by the `results` property of request.

The `PermissionResult` is the main advantage of using the API instead for the Activity result APIs.
Instead of being a simple `Boolean` for granted/denied it is an enum with `GRANTED`, `DENIED`
and `DENIED_PERMANENTLY`. After it receives the result from the contract, the library will
internally use `Activity.shouldShowRequestPermissionRationale(permission)` to figure out if a
denial was a permanent, meaning the user won't be asked again, or not. This is usually not easily
possible since it requires a reference to an `Activity`.

An example usage can look like this:
```kotlin
class MyNavigator : NavEventNavigator() {
    // use permissionRequest.results somewhere to handle results
    val permissionRequest = registerForPermissionsResult()

    fun requestContactsPermission(uri: Uri) {
        requestPermissions(permissionRequest, Manifest.permission.CAMERA)
    }

    fun requestLocationPermissions() {
        requestPermissions(
            permissionRequest,
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.ACCESS_FINE_LOCATION,
        )
    }
}
```

### Destination results

The last result API of the library is for returning hand handling results from screens inside
the app that also use `NavEventNavigator`.

The setup is similar to Activity results and permissions. The
`registerForNavigationResult<Route, Result>` needs to be called during construction of the navigator
or shortly after. `Route` in this case should be the `NavRoute` class for the curren screen. While
`Result` is the type of the expected result which can be any `Parcelable` class. The register method
will like the others than return a request object, which has `results` property that returns a
`Flow<Result>` to collect the results.

The navigation to the screen from which the result should be returned is a regular call to
`navigateTo`. However the `NavRoute` class for that target destination should have
`NavigationResultRequest.Key<Result>` as a parameter. An instance of such a `Key` can be obtained
from the `key` property of the request object.

The target screen can then simply call `devliverNavigationResult(route.key, result)` on its own
navigator to send the result and afterwards remove itself from the back stack with `navigateBack`.

The navigator for a hypothetical `ScreenA` that wants to receive a result from `ScreenB` would look
like this
```kotlin
data class MessageResult(val message: String): Parcelable

class ScreenANavigator : NavEventNavigator() {
    // use request.results somewhere to handle the results that ScreenB delivers
    val request = registerForNavigationResult<ScreenARoute, MessageResult>

    fun navigateToScreenB() {
        // if needed ScreenBRoute could also have additional parameters
        navigateTo(ScreenBRoute(request.key))
    }
}
```

And then the navigator for `ScreenB`
```kotlin

class ScreenANavigator(
   val route: ScreenBRoute
) : NavEventNavigator() {

    fun deliverMessage(message: String) {
        deliverNavigationResult(route.key, MessageResult(message))
    }
}
```

### Testing

The `NavEventNavigator` exposes a `navEvents` property that has `Flow<NavEvent>` as type. On any
of the navigation calls this `Flow` will emit a new `NavEvent`. To test logic that triggers
navigation this can be used together with the [Turbine library](https://github.com/cashapp/turbine)
to assert that the correct events are emitted.

```kotlin
navigator.navEvents.test {
    navigator.navigateTo(TestRoute())
    assertThat(awaitItem).isEqualTo(NavEvent.NavigateToEvent(TestRoute()))
    navigator.navigateBack()
    assertThat(awaitItem).isEqualTo(NavEvent.BackEvent)
}
```

This is a very simplified example, in reality the test would most likely not call the navigator
itself but some other code that uses the navigator internally.
